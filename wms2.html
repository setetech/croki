<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador 3D de Depósito WMS com Navegação Inteligente</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #canvas { display: block; }
        #title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 100; }
        #title a { color: #4CAF50; font-size: 32px; font-weight: bold; text-decoration: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); transition: color 0.3s; }
        #title a:hover { color: #45a049; }
        #info { position: absolute; top: 60px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; z-index: 100; }
        #input { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; z-index: 100; width: 250px; transition: opacity 0.3s; }
        #config { position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; z-index: 100; width: 250px; transition: opacity 0.3s; }
        .hidden { opacity: 0; pointer-events: none; }
        #addresses { width: 100%; height: 100px; margin-bottom: 10px; }
        button { width: 100%; padding: 5px; background: #4CAF50; color: white; border: none; border-radius: 3px; cursor: pointer; margin-bottom: 5px; }
        button:hover { background: #45a049; }
        label { display: block; margin-bottom: 5px; }
        input[type="number"] { width: 60px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="container">
        <div id="title">
            <a href="https://onblox.com.br/" target="_blank">OnBlox</a>
        </div>
        <div id="info">Endereço atual: N/A</div>
        <div id="input">
            <label>Lista de Endereços WMS (um por linha, ex: R1-P1-A1):</label><br>
            <textarea id="addresses">R1-P1-A1
R2-P5-A1
R3-P10-A1
R3-P4-A2</textarea>
            <br>
            <button onclick="startTour()">Iniciar Tour</button>
        </div>
        <div id="config">
            <label>Nº Ruas: <input type="number" id="numRuas" value="4" min="1"></label>
            <label>Nº Prédios: <input type="number" id="numPredios" value="20" min="1"></label>
            <label>Nº Níveis: <input type="number" id="numNiveis" value="3" min="1"></label>
            <label>Nº Apartamentos: <input type="number" id="numApart" value="2" min="1"></label>
            <br>
            <button onclick="generateWarehouse()">Gerar Depósito</button>
        </div>
    </div>
    <script>
        let numAisles = 4;
        let numBays = 20;
        let numLevels = 3;
        let numApart = 2;
        const bayLength = 1;
        const gap = 0.2;
        let totalLength;
        const headEnd = -1.5;
        let tailEnd;
        const aisleWidth = 3;
        const rackDepth = 2;
        const levelHeight = 2;
        const shelfHeight = 0.2;
        const itemHeight = 1.8;
        let aisleCenters = [];
        let rackPositions = [];
        const moveSpeed = 5;
        const stayTime = 5000;
        const moveSpeedCam = 20;

        const textureUrls = {
            stone: 'https://raw.githubusercontent.com/PixiGeko/Minecraft-default-assets/1.21/assets/minecraft/textures/block/stone.png',
            oak_planks: 'https://raw.githubusercontent.com/PixiGeko/Minecraft-default-assets/1.21/assets/minecraft/textures/block/oak_planks.png',
            dirt: 'https://raw.githubusercontent.com/PixiGeko/Minecraft-default-assets/1.21/assets/minecraft/textures/block/dirt.png',
            cobblestone: 'https://raw.githubusercontent.com/PixiGeko/Minecraft-default-assets/1.21/assets/minecraft/textures/block/cobblestone.png',
            barrel_side: 'https://raw.githubusercontent.com/PixiGeko/Minecraft-default-assets/1.21/assets/minecraft/textures/block/barrel_side.png'
        };

        let scene, camera, renderer, controls, clock, steve, racks = {};
        let textures = {};
        let tourTargets = [];
        let currentTargetIdx = 0;
        let waypoints = [];
        let currentWaypointIdx = 0;
        let isMoving = false;
        let isStaying = false;
        let startTimeStay;
        const keys = {};
        let animationStarted = false;
        let tourActive = false;
        let currentAisle = 0;

        function loadTextures(callback) {
            const loader = new THREE.TextureLoader();
            let loaded = 0;
            const total = Object.keys(textureUrls).length;
            Object.keys(textureUrls).forEach(key => {
                loader.load(textureUrls[key], (tex) => {
                    textures[key] = tex;
                    textures[key].magFilter = THREE.NearestFilter;
                    textures[key].minFilter = THREE.NearestFilter;
                    textures[key].wrapS = THREE.RepeatWrapping;
                    textures[key].wrapT = THREE.RepeatWrapping;
                    textures[key].generateMipmaps = false;
                    loaded++;
                    if (loaded === total) {
                        callback();
                    }
                });
            });
        }

        function generateWarehouse() {
            numAisles = parseInt(document.getElementById('numRuas').value) || 4;
            numBays = parseInt(document.getElementById('numPredios').value) || 20;
            numLevels = parseInt(document.getElementById('numNiveis').value) || 3;
            numApart = parseInt(document.getElementById('numApart').value) || 2;

            const baySpacing = bayLength + gap;
            totalLength = numBays * bayLength + (numBays - 1) * gap;
            tailEnd = totalLength + 1.5;

            aisleCenters = [];
            rackPositions = [];
            for (let i = 0; i < numAisles; i++) {
                const offset = i * (aisleWidth + rackDepth);
                aisleCenters.push(offset + 1.5);
                rackPositions.push(offset - 1);
            }

            let examples = [];
            if (numAisles >= 1) {
                examples.push(numApart > 1 ? 'A-01-01-01' : 'A-01-01');
            }
            if (numAisles >= 2) {
                examples.push(numApart > 1 ? 'B-05-02-01' : 'B-05-02');
            }
            if (numAisles >= 3) {
                examples.push(numApart > 1 ? 'C-10-03-01' : 'C-10-03');
            }
            const placeholderText = examples.join('&#10;');
            document.getElementById('addresses').placeholder = placeholderText;

            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            createWarehouse();

            steve = createSteve();
            steve.position.set(0, 0, aisleCenters[0]);
            scene.add(steve);

            tourTargets = [];
            currentTargetIdx = 0;
            isMoving = false;
            isStaying = false;
            tourActive = false;
            currentAisle = 0;
            document.getElementById('info').innerText = 'Endereço atual: N/A';

            if (!animationStarted) {
                animate();
                animationStarted = true;
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 15, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 100;

            clock = new THREE.Clock();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', (e) => keys[e.code] = true);
            document.addEventListener('keyup', (e) => keys[e.code] = false);
            renderer.domElement.addEventListener('click', onMouseClick);

            loadTextures(generateWarehouse);
        }

        function createWarehouse() {
            const minZ = rackPositions[0] - 2;
            const maxZ = aisleCenters[numAisles - 1] + 2;
            const totalWidth = maxZ - minZ;
            const floorCenterZ = (minZ + maxZ) / 2;

            const baySpacing = bayLength + gap;
            const minX = headEnd;
            const maxX = tailEnd - 1;
            const floorLength = maxX - minX;
            const floorCenterX = (minX + maxX) / 2;

            const floorGeo = new THREE.PlaneGeometry(floorLength, totalWidth);
            const floorMat = new THREE.MeshLambertMaterial({ map: textures.stone });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(floorCenterX, 0, floorCenterZ);
            floor.receiveShadow = true;
            scene.add(floor);

            const itemTypes = ['dirt', 'cobblestone', 'barrel_side'];
            racks = {};

            const subBayLength = bayLength / numApart;

            for (let aisleIdx = 0; aisleIdx < numAisles; aisleIdx++) {
                const rackZ = rackPositions[aisleIdx];
                const aisleLabel = `R${aisleIdx + 1}`;
                for (let bay = 0; bay < numBays; bay++) {
                    const group = new THREE.Group();
                    group.position.x = bay * (bayLength + gap) + bayLength / 2;
                    group.position.z = rackZ;
                    group.castShadow = true;
                    group.userData = { aisle: aisleLabel, bay: bay + 1 };

                    for (let level = 0; level < numLevels; level++) {
                        const y = level * levelHeight + shelfHeight / 2;
                        const shelfGeo = new THREE.BoxGeometry(bayLength - 0.1, shelfHeight, rackDepth - 0.1);
                        const mat = new THREE.MeshLambertMaterial({ map: textures.oak_planks });
                        const shelf = new THREE.Mesh(shelfGeo, mat);
                        shelf.position.y = y;
                        shelf.castShadow = true;
                        group.add(shelf);

                        for (let apart = 0; apart < numApart; apart++) {
                            const slotOffsetX = (apart - (numApart - 1) / 2) * subBayLength;
                            const slotGeo = new THREE.BoxGeometry(subBayLength - 0.05, shelfHeight, rackDepth - 0.1);
                            const box = new THREE.Mesh(slotGeo, mat);
                            box.position.x = slotOffsetX;
                            box.position.y = y;
                            box.position.z = 0;
                            box.castShadow = true;
                            const address = `${aisleLabel}-P${bay + 1}-A${apart + 1}`;
                            box.userData.address = address;
                            group.add(box);

                            if (Math.random() > 0.7) {
                                const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                                const itemMat = new THREE.MeshLambertMaterial({ map: textures[itemType] });
                                const itemGeo = new THREE.BoxGeometry(subBayLength - 0.1, itemHeight, 1);
                                const item = new THREE.Mesh(itemGeo, itemMat);
                                item.position.x = slotOffsetX;
                                item.position.y = level * levelHeight + shelfHeight + itemHeight / 2;
                                item.position.z = 0;
                                item.castShadow = true;
                                item.userData.address = address;
                                group.add(item);
                            }
                        }
                    }

                    scene.add(group);
                    const key = `${aisleLabel}P${bay + 1}`;
                    racks[key] = group;
                }
            }
        }

        function createSteve() {
            const group = new THREE.Group();

            const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const headMat = new THREE.MeshLambertMaterial({ color: 0xFDBCB4 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.1;
            head.castShadow = true;
            group.add(head);

            const torsoGeo = new THREE.BoxGeometry(0.8, 1.2, 0.4);
            const torsoMat = new THREE.MeshLambertMaterial({ color: 0x3C44AA });
            const torso = new THREE.Mesh(torsoGeo, torsoMat);
            torso.position.y = 1.35;
            torso.castShadow = true;
            group.add(torso);

            const armGeo = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const armMat = new THREE.MeshLambertMaterial({ color: 0x3C44AA });
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.6, 1.35, 0);
            leftArm.castShadow = true;
            group.add(leftArm);
            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0.6, 1.35, 0);
            rightArm.castShadow = true;
            group.add(rightArm);

            const legGeo = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const legMat = new THREE.MeshLambertMaterial({ color: 0x4C7C94 });
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.2, 0.6, 0);
            leftLeg.castShadow = true;
            group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.2, 0.6, 0);
            rightLeg.castShadow = true;
            group.add(rightLeg);

            return group;
        }

        function parseAddress(addr) {
            const match = addr.match(/R(\d+)-P(\d+)-A(\d+)/);
            if (!match) return null;
            const aisleNum = parseInt(match[1]);
            const bay = parseInt(match[2]);
            const apart = parseInt(match[3]);
            const aisleIdx = aisleNum - 1;
            if (aisleIdx < 0 || aisleIdx >= numAisles || bay < 1 || bay > numBays || apart < 1 || apart > numApart) return null;
            let x = (bay - 1) * (bayLength + gap) + bayLength / 2;
            const subBayLength = bayLength / numApart;
            const slotOffsetX = (apart - (numApart - 1) / 2) * subBayLength;
            x += slotOffsetX;
            const z = aisleCenters[aisleIdx];
            return { x, z, full: addr };
        }

        function startTour() {
            const text = document.getElementById('addresses').value;
            tourTargets = text.split('\n').map(line => line.trim()).filter(Boolean).map(parseAddress).filter(Boolean);
            if (tourTargets.length === 0) {
                document.getElementById('info').innerText = 'Nenhum endereço válido encontrado. Verifique o formato e os parâmetros do depósito.';
                return;
            }
            document.getElementById('info').innerText = `Iniciando tour para ${tourTargets.length} endereços...`;
            currentTargetIdx = 0;
            currentAisle = 0;
            steve.position.x = headEnd;
            steve.position.z = aisleCenters[0];
            nextTarget();
            tourActive = true;

            // Ocultar painéis durante o tour
            document.getElementById('input').classList.add('hidden');
            document.getElementById('config').classList.add('hidden');

            camera.position.set(totalLength / 2, 30, totalLength / 2 + 10);
            controls.target.set(totalLength / 2, 0, totalLength / 2);
            controls.update();
        }

        function nextTarget() {
            if (currentTargetIdx >= tourTargets.length) {
                isMoving = false;
                isStaying = false;
                tourActive = false;
                document.getElementById('info').innerText = 'Tour concluído';
                
                // Mostrar painéis novamente
                document.getElementById('input').classList.remove('hidden');
                document.getElementById('config').classList.remove('hidden');
                return;
            }
            const target = tourTargets[currentTargetIdx];
            const currX = steve.position.x;
            const currZ = steve.position.z;
            const targX = target.x;
            const targZ = target.z;
            const sameAisle = Math.abs(currZ - targZ) < 0.1;
            let endX;
            if (sameAisle) {
                waypoints = [{ x: targX, z: currZ }];
            } else {
                const headDist = Math.abs(currX - headEnd) + Math.abs(targX - headEnd) + Math.abs(currZ - targZ);
                const tailDist = Math.abs(currX - tailEnd) + Math.abs(targX - tailEnd) + Math.abs(currZ - targZ);
                endX = headDist < tailDist ? headEnd : tailEnd;
                waypoints = [
                    { x: endX, z: currZ },
                    { x: endX, z: targZ },
                    { x: targX, z: targZ }
                ];
            }
            currentWaypointIdx = 0;
            isMoving = true;
            isStaying = false;
            const addrParts = target.full.split('-');
            highlightBay(addrParts[0] + addrParts[1]);
            document.getElementById('info').innerText = `Indo para: ${target.full}`;
        }

        function highlightBay(key) {
            Object.keys(racks).forEach(k => {
                racks[k].traverse(child => {
                    if (child.isMesh && child.material.map) {
                        child.material.color.setHex(0xffffff);
                    }
                });
            });
            if (racks[key]) {
                racks[key].traverse(child => {
                    if (child.isMesh && child.material.map) {
                        child.material.color.setHex(0xFF0000);
                    }
                });
            }
        }

        function updateCamera(delta) {
            const frontVector = new THREE.Vector3(0, 0, -1);
            frontVector.applyQuaternion(camera.quaternion);
            frontVector.y = 0;
            frontVector.normalize();
            const rightVector = new THREE.Vector3();
            rightVector.crossVectors(frontVector, new THREE.Vector3(0, 1, 0)).normalize();
            if (keys['KeyW']) camera.position.add(frontVector.clone().multiplyScalar(moveSpeedCam * delta));
            if (keys['KeyS']) camera.position.add(frontVector.clone().multiplyScalar(-moveSpeedCam * delta));
            if (keys['KeyA']) camera.position.add(rightVector.clone().multiplyScalar(-moveSpeedCam * delta));
            if (keys['KeyD']) camera.position.add(rightVector.clone().multiplyScalar(moveSpeedCam * delta));
        }

        function onMouseClick(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                let address = obj.userData.address;
                if (!address) {
                    let parent = obj.parent;
                    while (parent && !address) {
                        if (parent.userData.address) address = parent.userData.address;
                        parent = parent.parent;
                    }
                }
                if (address) {
                    const status = Math.random() > 0.5 ? 'Ocupado' : 'Livre';
                    const tipo = ['Palete', 'Caixa', 'Vazio'][Math.floor(Math.random() * 3)];
                    document.getElementById('info').innerText = `Clicado: ${address} | Status: ${status} | Tipo: ${tipo}`;
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            updateCamera(delta);

            const newAisleIdx = aisleCenters.findIndex(z => Math.abs(steve.position.z - z) < 0.5);
            if (newAisleIdx !== -1 && newAisleIdx !== currentAisle) {
                currentAisle = newAisleIdx;
            }

            if (tourActive && (isMoving || isStaying)) {
                if (isMoving && Math.abs(steve.position.z - aisleCenters[currentAisle]) < 0.5) {
                    const behindDistance = 15;
                    const behindOffsetX = -behindDistance * Math.cos(steve.rotation.y);
                    const behindOffsetZ = -behindDistance * Math.sin(steve.rotation.y);
                    camera.position.set(
                        steve.position.x + behindOffsetX,
                        8,
                        steve.position.z + behindOffsetZ
                    );
                    controls.target.set(
                        steve.position.x,
                        2,
                        steve.position.z
                    );
                    controls.update();
                } else if (isStaying) {
                    const aisleZ = aisleCenters[currentAisle];
                    const heightAbove = 25;
                    const offsetBack = 5;
                    
                    camera.position.set(
                        steve.position.x - offsetBack,
                        heightAbove,
                        aisleZ
                    );
                    
                    controls.target.set(
                        steve.position.x,
                        0,
                        aisleZ
                    );
                    controls.update();
                }
            }

            if (isMoving && !isStaying) {
                const targetPos = waypoints[currentWaypointIdx];
                let dirX = targetPos.x - steve.position.x;
                let dirZ = targetPos.z - steve.position.z;
                let dirLen = Math.sqrt(dirX * dirX + dirZ * dirZ);
                const epsilon = 0.01;
                if (dirLen < epsilon) {
                    currentWaypointIdx++;
                    if (currentWaypointIdx >= waypoints.length) {
                        isMoving = false;
                        isStaying = true;
                        startTimeStay = performance.now();
                        document.getElementById('info').innerText = `Chegou em: ${tourTargets[currentTargetIdx].full}`;
                    }
                    return;
                }
                const moveDist = moveSpeed * delta;
                if (moveDist >= dirLen) {
                    steve.position.x = targetPos.x;
                    steve.position.z = targetPos.z;
                } else {
                    dirX /= dirLen;
                    dirZ /= dirLen;
                    steve.position.x += dirX * moveDist;
                    steve.position.z += dirZ * moveDist;
                }
                steve.rotation.y = Math.atan2(dirZ, dirX);
            } else if (isStaying) {
                if (performance.now() - startTimeStay > stayTime) {
                    currentTargetIdx++;
                    nextTarget();
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
